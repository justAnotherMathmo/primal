\title{Counting Primes}
% \author{
%         Vitaly Surazhsky \\
%                 Department of Computer Science\\
%         Technion---Israel Institute of Technology\\
%         Technion City, Haifa 32000, \underline{Israel}
%             \and
%         Yossi Gil\\
%         Department of Computer Science\\
%         Technion---Israel Institute of Technology\\
%         Technion City, Haifa 32000, \underline{Israel}
% }
\date{\today}

\documentclass[12pt]{article}
%\usepackage{bbm}
\usepackage{amsmath}
\usepackage{hyperref}

\begin{document}
\maketitle

\begin{abstract}
Here we briefly detail the algorithms used within to evaluate $\pi(x)$ - the number of prime numbers less than $x$ \ldots
\end{abstract}

\section{The Maths}
\subsection{Notation}
Let $\mu(n)$ be the M\"{o}bius function, $\gamma(n)$ the largest prime factor of $n$ and $\delta(n)$ the smallest prime factor of $n$.

\subsection{Sieve of Eratosthenes}
This is the algorithm everyone knows - but it's worth detailing, because it feeds into the combinatorial algorithms.
The sieve of Eratosthenes works by writing down a bit for each number from 2 to $x$. Then you walk along the sieve
until you hit a bit at position $p$ that's on. This number is a prime number, so you flip every bit that's a multiple
of $p$. As a minor optimisation, all numbers less than $p^2$ will already have their final status determined, so you
can start there and work up to $x$. Then, when you reach $\sqrt{x}$, you can stop and count - every number in the sieve
will have its final status.

\subsection{Legendre's Method}
This works by thinking about the sieve of Eratosthenes. First, we define a function $\phi(x,a)$ to be the number of
numbers at most $x$ that are coprime to the first $a$ prime numbers. Then, for the same reason that we can stop
crossing off numbers at $\sqrt{x}$ (i.e. every between $\sqrt{x}$ and $x$ is either prime or has a factor at
most $\sqrt{x}$), we get that:
$$\pi(x) = \pi\left(\sqrt{x}\right) + \phi\left(x, \pi\left(\sqrt{x}\right)\right) - 1$$
Here, $\pi\left(\sqrt{x}\right)$ counts the number of prime numbers below $\sqrt{x}$, whereas 
$\phi\left(x, \pi\left(\sqrt{x}\right)\right) - 1$ counts the number of primes between $\sqrt{x}$ and $n$. We need the
minus 1 there as 1 is coprime to every number, so the $\phi$ term counts it as well.

\subsubsection{Evaluation of $\phi$}
The reason this might be a good idea is that we have a recurrence we can use to evaluate $\phi$. If $p_a$ is the
$a$th prime, then:
\begin{equation}
\label{eq:phi-recurrence}
\phi(x,a) = \phi(x, a-1) - \phi(x/p_a, a-1)
\end{equation}
We get this by thinking about numbers that are or aren't coprime to $p_a$ below $x$. Many of the further methods
either try to reduce the value of $a$ in this evaluation, or reduce the depth at which we need to recurse.

\subsection{The Meissel-Lehmer Method}
Legendre's method by itself doesn't really help - we need an optimisation. We split the evaluation of $\phi$ into an
infinite class of functions - define $P_k(x, a)$ to be the number of numbers at most $x$ that have exactly $k$ prime
factors (not necessarily distinct) and that are coprime to the first $a$ prime numbers. Then, clearly:
$$\phi(x,a) = \sum_{k=0}^{\infty}P_k(x,a)$$
Notice that $P_0(x,a)=1$ for $x\geq1$.
But also, provided that $a\leq\pi(x)$, we have (as $P_1$ counts terms with exactly 1 prime factor):
$$P_1(x,a)=\pi(x) - a$$
And hence, for $a\leq\pi(x)$ and $x\geq1$ we have:
$$\pi(x) = a - 1 + \phi(x,a) - \sum_{k=2}^{\infty}P_k(x,a)$$
The reason that we transform the expression in this way, is that the minimum value of an integer that can
contribute to the expression $P_k(x,a)$ is $p_{a+1}^k$. Hence, if $a\geq\pi\left(\sqrt[k]{x}\right)$, we have
that $P_k(x,a) = 0$. This gives us our first practical methods for larger numbers - set $a=\pi\left(\sqrt[4]{x}\right)$
(Meissel's method) or set $a=\pi\left(\sqrt[3]{x}\right)$.

\subsubsection{Meissel's Method}
Chronologically, this method came first, but isn't the method that most other ones build off of. Perhaps this
is because Meissel did not yet have the advantage of computers, so the advantage of evaluating a much smaller
tree of $\phi$ was worth more than the simplicity of Lehmer's method.

Here we set $a=\pi\left(\sqrt[4]{x}\right)$

\subsubsection*{Evaluation of $P_2$}
If $x=pq$ with $p$ and $q$ primes, then $x/p$ is prime. For a term to contribute to $P_2(x,a)$, we must then
have that $p,q>p_a$ and hence, by fixing $p$ as the smaller prime, we want to evaluate:

\begin{align*}
  P_2(x,a)
    &=\sum_{b=a+1}^{\pi(\sqrt{x})}\left(\pi\left(x/p_b\right) - (b - 1)\right)\\
    &=\frac{a(a-1)}{2}-\frac{\pi\left(\sqrt{x}\right)(\pi\left(\sqrt{x}\right)-1)}{2}
      +\sum_{b=a+1}^{\pi(\sqrt{x})}\pi\left(x/p_b\right)
  \end{align*}

\subsubsection*{Evaluation of $P_3$}
Similarly to $P_2$, we get that:
\begin{equation*}
  P_3(x,a)
    =\sum_{b=a+1}^{\pi(\sqrt[3]{x})}\sum_{c=b}^{\pi(\sqrt[3]{x})}\left(\pi\left(\frac{x}{p_bp_c}\right) - (c - 1)\right)
  \end{equation*}

\subsubsection{Lehmer's Method}
Very similar to Meissel's method, except we set $a$ to a larger value at $a=\pi\left(\sqrt[3]{x}\right)$. This
has the benefit of making the calculation of $P_2$ slightly easier, and sets the $P_3$ term to 0. We don't
use this method here, as it proves to be slower than Meissel's.

\subsection{The Lagarias-Miller-Odlyzko Method}
The LMO method introduces the ability to parallelise the computation, as well as reduce the size
of the tree that gets computed. Here, set $a=\pi\left(\sqrt[3]{x}\right)$

\subsubsection{Computation of $P_2$}
This is as above. The computation is done in parallel by sieving blocks of the interval.

%\subsubsection{Computation of $\phi$}
%This is done differently - here we prune the tree a little. We make the distinction between an ``ordinary leaf'' and a ``special leaf''.
%This is used to decide when to note use the recurrence to compute a node $\phi\left(\frac{x}{n},b\right)$. For an \emph{ordinary leaf}, we have
%$b=0$ and $n\leq x^{1/3}$, whereas for a \emph{special leaf} $n > x^{1/3}$. We will impose further restrictions on special leaves in a second, 
%to ensure that we don't double count them.
%
%The computation being done is:
%
%$$\phi\left(x,\pi\left(x^{1/3}\right)\right) = \sum_{(n,0)\ \mathrm{ordinary}}\mu(n)\phi\left(\frac{x}{n},0\right) +
%                        \sum_{(n,b)\ \mathrm{special}}\mu(n)\phi\left(\frac{x}{n},b\right)$$
%
%Hence, we can restrict our attention to squarefree values of $n$. Further, our path to getting to a special leave involves picking a decreasing
%set of primes for the factorisation of $n$, ending at $p_{b+1}$. Hence, for the special leaves we have
%$n=p_{\alpha_1}p_{\alpha_2}\cdots p_{\alpha_r}$ with $\pi\left(x^{1/3}\right) \geq \alpha_1 > \alpha_2 > \cdots > \alpha_r = b+1$
%and $n > x^{1/3} \geq \frac{n}{p_{b+1}}$. Note that here, $b$ is not fixed.

\subsubsection{Computation of $\phi$}
This is done differently - here we prune the tree a little. We make the distinction between an ``ordinary leaf'' and a ``special leaf'' as
points at which we stop expanding the tree of computation that comes from the recurrence \eqref{eq:phi-recurrence}, so we use it to
decide whether or not to compute a node $\phi\left(\frac{x}{n},b\right)$.
Here, we pick some parameter $k$ and some value $x^{2/5} \geq y \geq x^{1/3}$. For an \emph{ordinary leaf}, we have
$b=k$ and $n\leq y$, whereas for a \emph{special leaf} we have $n > y$.

The computation being done is:

$$\phi\left(x,\pi\left(x^{1/3}\right)\right) = \sum_{(n,0)\ \mathrm{ordinary}}\mu(n)\phi\left(\frac{x}{n},0\right) +
                        \sum_{(n,b)\ \mathrm{special}}\mu(n)\phi\left(\frac{x}{n},b\right)$$

Hence, we can restrict our attention to squarefree values of $n$.

Now, we could enumerate all the positions by looking at the tree top-down, but it's going to be more efficient if we just know the terms
we'll need to compute the values at. Notice that we stop the computation if we either hit a second argument of $k$ (i.e. get to an ordinary leaf)
or make $n>y$ (i.e. hit a special leaf). Further, notice that each squarefree number with prime factors all less than $x^{1/3}$ occurs at most
once in the tree (dropping out if we hit a leaf). Hence, we need to compute a special leaf if that is the point at which we make $n>y$. 

This means that we need to compute (for the ordinary leaves), all squarefree values of $n\leq y$ with prime factors at most $x^{1/3}$.

For the special leaves, as the node above it wasn't a special leaf, the node $\phi\left(\frac{x}{n}, b\right)$ must have $p_{b+1}n > y$.
Hence, we have that special leaves are exactly the values with $p_{b+1}n \geq y > n, \delta(n) = p_{b+1}, \gamma(n) \leq x^{1/3}$
and $n$ squarefree.

\subsubsection{Parallelism}
The above algorithm can be implemented in parallel - as can the later methods. To do this, we need some precomputation. All primes below $x^{1/3}$
need to be computed so that they can be used to sieve blocks of length at least $x^{1/3}$.

\subsection{The Delaglise-Rivat Method}
Not documented here. It's similar to the Gourdon method, but slower. There's a very good paper on this, mentioned in the references section.

\subsection{The Gourdon Method}
Fix values of $y,z$ s.t. $x^{1/3} < y \leq z < x^{1/2}$ as in Delaglise-Rivat, and let $k$ be a small (integer) constant. Let
\begin{equation*}
  \chi(\alpha) =
    \begin{cases}
      2\ \mathrm{if}\ \alpha < y\\
      1\ \mathrm{if}\ \alpha \geq y
    \end{cases}
\end{equation*}

Furthermore, let $a=\pi\left(y\right)$, $b=\pi\left(x^{1/3}\right)$, $c=\pi\left((x/y)^{1/2}\right)$, $d=\pi\left(x^*\right)$
and $x^*=\mathrm{max}\left(x^{1/4}, x/y^2\right)$. Then, define:
\begin{align*}
  A &= \sum_{x^* < p \leq x^{1/3}}\sum_{p < q \leq (x/p)^{1/2}}\chi\left(\frac{x}{pq}\right)\pi\left(\frac{x}{pq}\right)\\
  B &= \sum_{y < p \leq x^{1/2}}\pi\left(\frac{x}{p}\right)\\
  C &= -\sum_{p_k < p \leq x^*} \sum_{m: m\leq z<pm,\delta(m)>p,\gamma(m)\leq y, m>x/p^3}\mu(m)\left(\pi\left(\frac{x}{pm}\right)-\pi(p)+2\right)\\
  D &= -\sum_{p_k < p \leq x^*} \sum_{m: m\leq z<pm,\delta(m)>p,\gamma(m)\leq y, m\leq x/p^3}\mu(m)\phi\left(\frac{x}{pm},\pi(p)-1\right)\\
  \phi_0 &= \sum_{n\leq y,\delta(n) >p_k}\mu(n)\phi\left(\frac{x}{n}, k\right)\\
  \Sigma_0 &= a - 1 + \frac{\pi\left(x^{1/2}\right)\left(\pi\left(x^{1/2}\right) - 1\right)}{2} - \frac{a(a-1)}{2}\\
  \Sigma_1 &= \frac{(a-b)(a-b-1)}{2}\\
  \Sigma_2 &= a\left(b - c - \frac{c(c-3)}{2} + \frac{d(d-3)}{2}\right)\\
  \Sigma_3 &= \frac{b(b-1)(2b-1)}{6} - b - \frac{d(d-1)(2d-1)}{6} + d\\
  \Sigma_4 &= \pi(y) \sum_{x^* < p \leq (x/y)^{1/2}}\pi\left(\frac{x}{py}\right)\\
  \Sigma_5 &= \sum_{(x/y)^{1/2} < p \leq x^{1/3}}\pi\left(\frac{x}{p^2}\right)\\
  \Sigma_6 &= -\sum_{x^* < p \leq x^{1/3}}\pi\left(\frac{x^{1/2}}{p^{1/2}}\right)^2\\
  \Sigma &= \Sigma_0 + \Sigma_1 + \Sigma_2 + \Sigma_3 + \Sigma_4 + \Sigma_5 + \Sigma_6
\end{align*}

Then, we have that:

\[
  \pi(x) = A - B + C + D + \phi_0 + \Sigma  
\]

As is the case in the other methods, to make this optimal we pick $y=Kx^{1/3}\log^3(x)\log\log(x)$, with $K$ a parameter to be optimised around,
but should be within an order of magnitude of 1 (I think). Further, we pick $z = Ly$ with $L>1$ as a parameter to be optimised.

\section{References}
LMO: \url{http://www.dtc.umn.edu/~odlyzko/doc/arch/meissel.lehmer.pdf} \\
DR: \url{http://sweet.ua.pt/tos/bib/5.4.pdf} \\
Gourdon: \url{http://numbers.computation.free.fr/Constants/Primes/Pix/pixtableproject.html}

\end{document}